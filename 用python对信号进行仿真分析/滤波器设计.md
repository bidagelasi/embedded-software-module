当我们需要设计信号处理算法时，可以使用现成的工具来进行信号仿真与分析，为我们算法设计提供指导。在仿真与分析工具中，有名当然是MATLAB，而后起之秀是Python。Python有十分强大且免费的第三方库，包含各种信号处理算法。从这篇文章开始，我将围绕Python的Numpy、Scipy、matplotlib、pandas以及其他的第三方库来完成（低通、高通、带通等）滤波器设计、陷波器、FFT、希尔伯特变换、希尔伯特-黄变换、小波变换，以便理解与使用这些看似高大上的信号处理算法，知道什么时候可以尝试使用什么算法。

首先，看看滤波器的设计。

一般而言，滤波器按照滤波方式可分为低通滤波、高通滤波、带通滤波、带阻滤波。按照滤波器种类，又可分为巴特沃斯滤波器、椭圆滤波、切比雪夫滤波、贝塞尔滤波器等。下面，先看看如何用Pyhton设计一个滤波器，然后利用这个滤波器看看实际的滤波效果，最后对比一下椭圆滤波器、切比雪夫滤波器、贝塞尔滤波器等幅频特性。

先看问题。我们现在需要设计一个椭圆滤波器，要求滤波器阶数为10，通带范围20~100HZ，通带的纹波最大1dB，阻带最小衰减60dB，采样率为1k。用python的scipy模块的signal模块来设计这个滤波器。代码如下：

```
# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

#iirfilter函数参数说明，详见[1]
#第一个参数是滤波器的阶数
#第二个参数是滤波器的通带频率
#rp是通带纹波最大波动1dB
#rs是阻带最小衰减
#btype是滤波器的滤波方式，除了band以外，还有lowpass、highpass等
#analog是选择该滤波器为模拟滤波器(True)还是数字滤波器(False)
#ftype是滤波器的种类，除了ellip，还有bessel、cheby2等
#fs为数字信号的采样率
#output是滤波器函数的返回值类型，这也是官方推荐的返回值类型
sos = signal.iirfilter(10,[20,100], rp = 1, rs=60, btype='bandpass',
                       analog=False, ftype='ellip',fs=1000,output='sos')
#通过iirfilter得到了滤波器，我们接着使用sosfreqz获得该滤波器的频率响应
#sosfreqz的函数参数说明,详见[2]
#第一个参数就是上述滤波器的返回值
#第二个参数是需要计算的频率点数
#fs表示采样率
#返回值w表示频率值
#返回值h的模表示幅度
w,h = signal.sosfreqz(sos,1000, fs=1000)

#下面的代码是现实幅频特性
plt.title('Frequency Response')
plt.xlabel('Frequency [Hz]')
plt.ylabel('Amplitude [dB]')
plt.semilogx(w, 20 * np.log10(abs(h)))
plt.axis((10, 1000, -100, 10))
plt.show()
```
上述滤波器的幅频特性如下图所示。

![滤波器](https://github.com/liuhao1946/embedded-software-module/blob/master/%E7%94%A8python%E5%AF%B9%E4%BF%A1%E5%8F%B7%E8%BF%9B%E8%A1%8C%E4%BB%BF%E7%9C%9F%E5%88%86%E6%9E%90/png/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%AE%BE%E8%AE%A1/%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%B9%85%E9%A2%91%E5%93%8D%E5%BA%94.png)


